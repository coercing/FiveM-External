#pragma once
#include <Includes/Includes.hpp>
#include <Includes/Utils.hpp>
#include <Core/Offsets.hpp>
#include <Core/Core.hpp>
#include <iostream>
#include <fstream>
#include <string>
#include <regex>

namespace Core
{
	namespace Features
	{
		namespace Exploits
		{
			inline void NoClip()
			{
				Core::SDK::Pointers::pLocalPlayer->FreezePed(true);

				D3DXVECTOR3 LocalPos = Core::SDK::Pointers::pLocalPlayer->GetPos();
				if (LocalPos == D3DXVECTOR3(0, 0, 0))
					return;

				uintptr_t PedNavigation = Core::SDK::Pointers::pLocalPlayer->GetNavigation();
				if (!PedNavigation)
					return;

				Mem.Write(PedNavigation + 0x30, D3DXVECTOR3(0, 0, 0));

				uintptr_t CamFollowPedCamera = Mem.Read<uintptr_t>(Core::SDK::Pointers::pCamGamePlayDirector + 0x2C0);
				if (!CamFollowPedCamera)
					return;

				D3DXVECTOR3 TPSAngles = Mem.Read<D3DXVECTOR3>(CamFollowPedCamera + 0x40);

				if (TPSAngles == D3DXVECTOR3(0, 0, 0))
				{
					TPSAngles = Mem.Read<D3DXVECTOR3>(CamFollowPedCamera + 0x40);
				}
				else if (TPSAngles != D3DXVECTOR3(0, 0, 0))
				{
					D3DXVECTOR3 NewPos = LocalPos;
					float Speed = g_Config.Player->NoClipSpeed / 100.f;

					if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
						Speed *= 5.f; // Boost

					// Direção frontal (W/S)
					if (GetAsyncKeyState(0x57) & 0x8000) { // W
						NewPos.x += TPSAngles.x * Speed;
						NewPos.y += TPSAngles.y * Speed;
						NewPos.z += TPSAngles.z * Speed;
					}
					if (GetAsyncKeyState(0x53) & 0x8000) { // S
						NewPos.x -= TPSAngles.x * Speed;
						NewPos.y -= TPSAngles.y * Speed;
						NewPos.z -= TPSAngles.z * Speed;
					}

					// Direção lateral (A/D)
					D3DXVECTOR3 rightVec;
					rightVec.x = -TPSAngles.y;
					rightVec.y = TPSAngles.x;
					rightVec.z = 0; // Mantém no plano horizontal (sem elevação)

					if (GetAsyncKeyState(0x44) & 0x8000) { // D
						NewPos.x -= rightVec.x * Speed;
						NewPos.y -= rightVec.y * Speed;
					}
					if (GetAsyncKeyState(0x41) & 0x8000) { // A
						NewPos.x += rightVec.x * Speed;
						NewPos.y += rightVec.y * Speed;
					}

					if (GetAsyncKeyState(0x20) & 0x8000) { // Space
						NewPos.z += 1.0f; // Ajuste o valor para a altura desejada
					}

					if (NewPos != LocalPos) {
						Mem.Write(reinterpret_cast<uintptr_t>(Core::SDK::Pointers::pLocalPlayer) + 0x90, NewPos);
						Mem.Write(PedNavigation + 0x50, NewPos);
					}
				}
			}	

			inline void TpToWaypoint( ) {
				for ( int i = 0; i < 2000; i++ ) 
				{
					uintptr_t Blip = Mem.Read<uintptr_t>( g_Offsets.m_BlipList + ( 8U * i ) );
					if ( !Blip )continue;

					int BlipIcon = Mem.Read<int>( Blip + 0x40 );
					int BlipColor = Mem.Read<int>( Blip + 0x48 );

					if ( BlipIcon != 8 )continue;

					D3DXVECTOR2 BlipPos = Mem.Read<D3DXVECTOR2>( Blip + 0x10 );

					Core::SDK::Pointers::pLocalPlayer->SetPos( D3DXVECTOR3( BlipPos.x, BlipPos.y, -210.f ) );

				}
			}
		}
	}
}
