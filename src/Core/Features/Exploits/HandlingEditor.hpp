#pragma once
#include <Includes/Includes.hpp>
#include <Includes/Utils.hpp>
#include <Core/Offsets.hpp>
#include <Core/Core.hpp>
#include <iostream>
#include <fstream>
#include <string>
#include <regex>
#include <mutex>

namespace Core
{
	namespace Features
	{
		namespace Exploits
		{
			class cHandlingEditor
			{
			private:
				CVehicle* CurrentVeh = nullptr;
				uintptr_t CurrentHandling = 0;

			public:
				// Defaults
				float AccelerationDefault = 0.f;
				float BrakeForceDefault = 0.f;
				float TractionCurveMinDefault = 0.f;

				// Edited
				float fAcceleration = 0.f;
				float fBrakeForce = 0.f;
				float fTractionCurveMin = 0.f;

			private:
				void GetHandling()
				{
					CVehicle* newVeh = Core::SDK::Pointers::pLocalPlayer->GetLastVehicle();
					if (!newVeh)
					{
						CurrentVeh = nullptr;
						CurrentHandling = 0;
						return;
					}

					if (newVeh != CurrentVeh)
					{
						CurrentVeh = newVeh;
						CurrentHandling = CurrentVeh->GetHandling();

						// Read default values of the new vehicle
						SaveHandlingValues();

						// Apply current edited values to the new vehicle
						ApplyHandlingValues();
					}
				}

			public:
				void ReadHandlingValues()
				{
					GetHandling();

					if (!CurrentHandling) return;

					fAcceleration = Mem.Read<float>(CurrentHandling + offsetof(CHandlingData, m_acceleration));
					fBrakeForce = Mem.Read<float>(CurrentHandling + offsetof(CHandlingData, m_brake_force));
					fTractionCurveMin = Mem.Read<float>(CurrentHandling + offsetof(CHandlingData, m_traction_curve_min));
				}

				void ApplyHandlingValues()
				{
					GetHandling();

					if (!CurrentHandling) return;

					Mem.Write<float>(CurrentHandling + offsetof(CHandlingData, m_acceleration), fAcceleration);
					Mem.Write<float>(CurrentHandling + offsetof(CHandlingData, m_brake_force), fBrakeForce);
					Mem.Write<float>(CurrentHandling + offsetof(CHandlingData, m_traction_curve_min), fTractionCurveMin);
				}

				void SaveHandlingValues()
				{
					GetHandling();

					if (!CurrentHandling) return;

					AccelerationDefault = Mem.Read<float>(CurrentHandling + offsetof(CHandlingData, m_acceleration));
					BrakeForceDefault = Mem.Read<float>(CurrentHandling + offsetof(CHandlingData, m_brake_force));
					TractionCurveMinDefault = Mem.Read<float>(CurrentHandling + offsetof(CHandlingData, m_traction_curve_min));

					fAcceleration = AccelerationDefault;
					fBrakeForce = BrakeForceDefault;
					fTractionCurveMin = TractionCurveMinDefault;
				}

				void RestoreHandlingValues()
				{
					GetHandling();

					if (!CurrentHandling) return;

					Mem.Write<float>(CurrentHandling + offsetof(CHandlingData, m_acceleration), AccelerationDefault);
					Mem.Write<float>(CurrentHandling + offsetof(CHandlingData, m_brake_force), BrakeForceDefault);
					Mem.Write<float>(CurrentHandling + offsetof(CHandlingData, m_traction_curve_min), TractionCurveMinDefault);

					fAcceleration = AccelerationDefault;
					fBrakeForce = BrakeForceDefault;
					fTractionCurveMin = TractionCurveMinDefault;
				}
			};

			inline cHandlingEditor g_HandlingEditor;
		}
	}
}
